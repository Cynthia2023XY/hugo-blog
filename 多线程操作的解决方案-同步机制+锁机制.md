---
sr-due: 2025-08-25
sr-interval: 411
sr-ease: 296
tags:
  - review_knowledge_code_js
  - review_knowledge_八股
---

#review/knowledge/code/js #review/knowledge/八股 

### 多线程同步问题

当多个线程试图同时访问和修改同一资源（如数据或文件）时，就需要确保这些操作是同步的，以避免产生错误的结果或破坏数据的完整性。
例如，如果两个线程同时对同一个变量进行写操作，最终变量的值可能取决于线程执行的顺序，这种情况是不可预测的，导致数据不一致。 ^occ2ga

[[为什么js要设计成单线程语言#1 避免并发问题：防止多个线程同时修改DOM树|为什么js要设计成单线程语言 > 1 避免并发问题：防止多个线程同时修改DOM树]]
![[为什么js要设计成单线程语言#1 避免并发问题：防止多个线程同时修改DOM树|为什么js要设计成单线程语言 > 1 避免并发问题：防止多个线程同时修改DOM树]] ^b946nu

---
### 锁

为了解决同步问题，通常会使用锁（Locks）机制。
锁可以帮助确保在任何给定时刻，只有一个线程可以访问特定的资源。
当一个线程获得对资源的锁时，其他试图访问该资源的线程将被阻塞，直到锁被释放。
```ad-hint
所以是获得锁的程序才可以执行操作，那么这个“锁”的概念实际上更像是“钥匙”
```
### 常见的锁问题

- **死锁（Deadlock）**：当两个或更多的线程在等待对方持有的锁时，就会发生死锁。这种情况下，所有相关线程都会无限等待，导致程序挂起。[[解决线程死锁DeadLock|解决线程死锁DeadLock]][[死锁Deadlock|死锁Deadlock]]
- **饥饿（Starvation）**：当一个或多个线程无法获得所需的锁，而持续处于等待状态时，会发生饥饿。这通常是因为锁的分配不公平，一些线程被优先处理。 ^28943e
- **活锁（Livelock）**：线程虽然没有被阻塞，能够执行，但是它们的操作都是无用功，无法向前推进程序的状态。这通常发生在两个线程尝试避免死锁的情况下，不断地在彼此之间转移资源，但没有一方能够继续执行。